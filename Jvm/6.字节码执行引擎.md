[6.字节码执行引擎]()
---------
`执行引擎`是虚拟机最核心组成之一
* 所有的执行引擎都是一致的:输入是字节码文件,处理过程是字节码解析的等效过程,输出的是执行结果
* 运行时`栈帧`结构
  * 栈帧存储了方法的`局部变量表`,`操作数栈`,`动态连接`和`方法返回地址`等,每一个方法调用到执行完成,都对应一个栈帧在虚拟机栈从入栈到出栈的过程
  * 字节码指令都只针对当前栈进行操作
* 局部变量表
  * 变量槽(Variable Slot)为最小单位   ,    虚拟机通过索引定位的方式使用局部变量表    ,    为尽可能节省栈帧空间,局部变量表中的Slot是可以重用的
  * 把`不使用的对象应手动赋值为null`,作用就是让局部变量表中的Slot复用,断开之前的引用,以便垃圾回收器回收,此法只在特定情况下使用
* 操作数栈
  * 先入后出  , 32位数据类型所占的栈容量为1,64的为2.   方法`刚执行`,操作数栈是`空`的
  * Java虚拟机的解释执行引擎称为`基于栈的执行引擎`,其中`栈`就是操作数栈
* 动态连接
  * 符号引用在`类加载阶段和第一次使用就转化为直接引用`,称为`静态解析`;符号引用在`每一次运行期间转化为直接引用`,称为`动态连接`
* 方法返回地址
  * `正常完成出口`：调用者的PC计数器的值可以作为返回地址 
  * `异常完成出口`：通过异常处理器表来确定，栈帧中一般不会保存这部分信息
* 附加信息
  * 实际开发，一般把动态连接，方法返回地址与其他附加信息全部归为一类，称为`栈帧信息`
  
方法调用
* 解析  -->  调用目标的程序代码写好,编译器进行编译时就必须确定下来
* 分派   
  * 静态分派 --  重载过程   -->属于多分派类型
  * 动态分派 --  重写过程   -->属于单分派类型
方法的接收者和方法的参数统称为方法的宗量 
* 单分派:根据一个宗量对目标方法进行选择
* 多分派:根据多于一个宗量对目标方法进行选择
方法表是分派调用的`稳定优化`手段,内联缓存和基于`类型继承关系分析`技术的守护内联的`激进优化`

基于栈的字节码解释执行引擎
* 解释执行
```
java语言中,javac编译器完成了程序代码经过词法分析,语法分析到抽象语法树,再遍历语法树生成线性的字节码指令流的过程.因为这一部分动作
是在java虚拟机之外进行的,而解释器在虚拟机的内部,所以java程序的编译就是半独立的实现.
```

基于栈的指令集与基于寄存器的指令集
```
基于栈的例子计算1+1
iconst_1
iconst_1
iadd
istore_0
```

基于栈的优点:`可移植`,`代码相对紧凑`,`编译器实现更加简单`,缺点:`执行速度相对稍慢`

```
基于寄存器例子计算1+1
mov eax=1
add eax=1
```

基于栈的解释器执行过程
* 整个运算过程的中间变量都以操作数栈的出栈/入栈为信息交换途径

