[运行期优化]()
```
虚拟机发现某个方法或代码块的运行特别频繁时,就会把这些代码认定为`热点代码`(Hot Spot Code).为了提高热点代码的执行效率,在运行时,虚拟机就会把这些代码编译成与本地平台相关的代码,并进行各种层次的优化,完成这个任务的编译器称为即时编译器(Just In Time Compiler,JIT编译器).
```
程序要迅速启动,`解释器`首先发挥作用,省去编译的时间,立即执行.在程序运行后,随着时间的推移,`编译器`逐渐发挥作用,把越来越多的代码编译成本地代码之后,可以获得更高的执行效率.

分层编译:
* 第0层,程序解释执行,解释器不开启性能监控功能,可触发第1层编译
* 第1层,C1编译,将字节码编译成本地代码,进行简单/可靠的优化,如有必要加入性能监控的逻辑
* 第2层,C2编译,也是将字节码编译成本地代码,但是会启用一些编译耗时较长的优化,甚至会根据性能监控信息进行一些不可靠的激进优化

实施分层编译,Client Compiler(C1)和Server Compiler(C2)将会同时工作,许多代码都可能会被多次编译,用Client Compiler获取`更高的编译速度`,用Server Compiler获取更好的编译质量,在解释执行的时候也无须再承担收集性能监控信息的任务

##### [编译对象与触发条件]()

`热点代码`:
* 被多次调用的方法
* 被多次执行的循环体

热点探测:判断是不是热点代码,是不是需要触发即时编译
* 基于采样的热点探测   -->简单/高效,但是难以精确确认一个方法的热度,一首干扰
* 基于计数器的热点探测  -->更加精确和严谨,但是复杂麻烦一些
  * 调用计数器  -- 阀值:Client -> 1500次   ,  Server -> 10000次
    * 超过一定时间限度,方法调用次数仍不足以让它提交JIT编译器编译,调用计数器就会减少一半,称为`计数器热度的衰减`(半衰周期)
  * 回边计数器  
    * Client模式.阀值计算公式:调用计数器阀值*OSR比率(默认值933)/100
    * Server模式.调用计数器阀值*OSR比率(默认值140)-解释器监控比率(默认值33)/100
    * 目的是为了触发OSR（On Stack Replace)编译

当计数器超多阀值溢出了,就会触发JIT编译

##### [编译过程]()
##### []()
* 语言无关的经典优化技术之一:公共子表达式消除
  * 如果一个表达式E已经计算过了，就没有必要再计算，只需替代（比如 int d =(c*b)*12+a+(a+b*c)  ,可以替换为int d =(E)*12+a+(a+E)
* 语言相关的经典优化技术之一:数组范围检查消除
* 最重要的优化技术之一:方法内联   --激进优化
* 最前沿的优化技术之一:逃逸分析
  * 栈上分配
    * 如果确定一个对象不会逃逸出方法之外,那让对象在桟上分配内存将会是一个很不错的主意,对象所占用的内存空间就可以随栈帧出栈而销毁
    * 一般应用中,不会逃逸的局部对象所占的比例很大,如果能使用桟上分配,大量的对象就会随着方法结束而销毁,垃圾收集系统压力就会小很多
  * 同步消除
    * 如果逃逸分析能确定一个变量不会逃逸出线程,无法被其他线程访问,这个变量读写就不会有竞争,对这个变量实施的同步措施就可消除掉
  * 标量替换
    * `标量`是指一个数据无法在分解成更小的数据表示,Java虚拟机的原始数据类型(int,long等数值类型及reference类型等)也是标量,相对的
    * 如果可以分解叫做`聚合量`,java对象就是聚合量.
    * 将一个java对象拆散,使其使用到的成员变量恢复原始类型来访问就叫做`标量替换`.

##### [Java与c/c++编译器对比]()
```
java compiler-------------vs--------------c/c++ compiler
--------------------------------------------------------
