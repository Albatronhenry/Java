[垃圾回收器与内存分配策略]()
#### 判断对象是否回收
* 引用计数法
  * 给每一个对象添加一个计数器,每当引用就+1;当引用实效,计数器就-1;任何时刻当对象不被引用,就视为可回收对象
  * 存在的问题:对象间相互引用而实际没有别的任何引用,导致无法回收
* 可达性分析算法
  * 从最基础的 GC Roots出发,当一个对象到GC Roots节点没有引用连相连,则视为可回收对象
#### 回收方法区
    方法区(或者HotSpot虚拟机中永久代)进行垃圾收集的`性价比`一般:新生代常规应用一次垃圾收集一般可以回收70%-
    95%的空间,而永久代效率远低于此.
*  永久代主要回收两部分:`废弃常量`和`无用的类`
  * `废弃常量`:与堆对象回收类似,没有引用即可回收
  * `无用的类`:
     * ① 该类所有实例都已被回收
     * ② 加载该类的ClassLoader已经被回收
     * ③ 对应java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法
虚拟机满足①-③个条件`可以`对无用的类回收,注意是`可以`,不是必然会回收.

#### 垃圾收集算法
* 标记-清除算法
* 标记-复制算法
* 标记-整理算法
下面的算法为现代商用虚拟机所采用:
* 分代收集算法
  * 新生代:复制算法
  * 老年代:标记整理-** 算法

#### HotSpot算法实现
* 枚举根节点  可达性分析算法 GC Roots节点,逐个检查必然耗时,对执行时间的敏感体现在GC停顿上
* 安全点（Safepoint)  到达安全点可以暂停 
   * 安全点选定基于 `是否有让程序长时间执行的特征` -->指令序列复用,例如方法调用/循环跳转/异常跳转等
 * 安全点实现方法:
   * 抢先式中断(现在虚拟机几乎不采用)
   * 主动式中断:简单设定一个标志,线程执行时主动轮询这个标志,发现中断标志为真就自己中断挂起,轮询标志和安全点是重合的
 * 安全区域
   * 解决线程处于Sleep/Blocaked状态,程序无法相应JVM的中断请求，`走`到安全点那个地方
   * 安全区的首先标识进入安全区,线程离开时检查是否完成根节点枚举(整个GC过程），如果完成线程就继续执行，否则就等待直到收到安全离开安全区信号为止
#### 3.5.6
